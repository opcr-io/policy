// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/aserto-dev/go-grpc/aserto/registry/v1 (interfaces: RegistryClient)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	registry "github.com/aserto-dev/go-grpc/aserto/registry/v1"
	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockRegistryClient is a mock of RegistryClient interface.
type MockRegistryClient struct {
	ctrl     *gomock.Controller
	recorder *MockRegistryClientMockRecorder
}

// MockRegistryClientMockRecorder is the mock recorder for MockRegistryClient.
type MockRegistryClientMockRecorder struct {
	mock *MockRegistryClient
}

// NewMockRegistryClient creates a new mock instance.
func NewMockRegistryClient(ctrl *gomock.Controller) *MockRegistryClient {
	mock := &MockRegistryClient{ctrl: ctrl}
	mock.recorder = &MockRegistryClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRegistryClient) EXPECT() *MockRegistryClientMockRecorder {
	return m.recorder
}

// CreateImage mocks base method.
func (m *MockRegistryClient) CreateImage(arg0 context.Context, arg1 *registry.CreateImageRequest, arg2 ...grpc.CallOption) (*registry.CreateImageResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateImage", varargs...)
	ret0, _ := ret[0].(*registry.CreateImageResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateImage indicates an expected call of CreateImage.
func (mr *MockRegistryClientMockRecorder) CreateImage(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateImage", reflect.TypeOf((*MockRegistryClient)(nil).CreateImage), varargs...)
}

// GetReadAccessToken mocks base method.
func (m *MockRegistryClient) GetReadAccessToken(arg0 context.Context, arg1 *registry.GetReadAccessTokenRequest, arg2 ...grpc.CallOption) (*registry.GetReadAccessTokenResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetReadAccessToken", varargs...)
	ret0, _ := ret[0].(*registry.GetReadAccessTokenResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetReadAccessToken indicates an expected call of GetReadAccessToken.
func (mr *MockRegistryClientMockRecorder) GetReadAccessToken(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReadAccessToken", reflect.TypeOf((*MockRegistryClient)(nil).GetReadAccessToken), varargs...)
}

// GetWriteAccessToken mocks base method.
func (m *MockRegistryClient) GetWriteAccessToken(arg0 context.Context, arg1 *registry.GetWriteAccessTokenRequest, arg2 ...grpc.CallOption) (*registry.GetWriteAccessTokenResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWriteAccessToken", varargs...)
	ret0, _ := ret[0].(*registry.GetWriteAccessTokenResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWriteAccessToken indicates an expected call of GetWriteAccessToken.
func (mr *MockRegistryClientMockRecorder) GetWriteAccessToken(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWriteAccessToken", reflect.TypeOf((*MockRegistryClient)(nil).GetWriteAccessToken), varargs...)
}

// ListDigests mocks base method.
func (m *MockRegistryClient) ListDigests(arg0 context.Context, arg1 *registry.ListDigestsRequest, arg2 ...grpc.CallOption) (*registry.ListDigestsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDigests", varargs...)
	ret0, _ := ret[0].(*registry.ListDigestsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDigests indicates an expected call of ListDigests.
func (mr *MockRegistryClientMockRecorder) ListDigests(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDigests", reflect.TypeOf((*MockRegistryClient)(nil).ListDigests), varargs...)
}

// ListImages mocks base method.
func (m *MockRegistryClient) ListImages(arg0 context.Context, arg1 *registry.ListImagesRequest, arg2 ...grpc.CallOption) (*registry.ListImagesResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListImages", varargs...)
	ret0, _ := ret[0].(*registry.ListImagesResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListImages indicates an expected call of ListImages.
func (mr *MockRegistryClientMockRecorder) ListImages(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListImages", reflect.TypeOf((*MockRegistryClient)(nil).ListImages), varargs...)
}

// ListOrgs mocks base method.
func (m *MockRegistryClient) ListOrgs(arg0 context.Context, arg1 *registry.ListOrgsRequest, arg2 ...grpc.CallOption) (*registry.ListOrgsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListOrgs", varargs...)
	ret0, _ := ret[0].(*registry.ListOrgsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListOrgs indicates an expected call of ListOrgs.
func (mr *MockRegistryClientMockRecorder) ListOrgs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOrgs", reflect.TypeOf((*MockRegistryClient)(nil).ListOrgs), varargs...)
}

// ListPublicImages mocks base method.
func (m *MockRegistryClient) ListPublicImages(arg0 context.Context, arg1 *registry.ListPublicImagesRequest, arg2 ...grpc.CallOption) (*registry.ListPublicImagesResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPublicImages", varargs...)
	ret0, _ := ret[0].(*registry.ListPublicImagesResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPublicImages indicates an expected call of ListPublicImages.
func (mr *MockRegistryClientMockRecorder) ListPublicImages(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPublicImages", reflect.TypeOf((*MockRegistryClient)(nil).ListPublicImages), varargs...)
}

// ListPublicOrgs mocks base method.
func (m *MockRegistryClient) ListPublicOrgs(arg0 context.Context, arg1 *registry.ListPublicOrgsRequest, arg2 ...grpc.CallOption) (*registry.ListPublicOrgsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPublicOrgs", varargs...)
	ret0, _ := ret[0].(*registry.ListPublicOrgsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPublicOrgs indicates an expected call of ListPublicOrgs.
func (mr *MockRegistryClientMockRecorder) ListPublicOrgs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPublicOrgs", reflect.TypeOf((*MockRegistryClient)(nil).ListPublicOrgs), varargs...)
}

// ListTagsWithDetails mocks base method.
func (m *MockRegistryClient) ListTagsWithDetails(arg0 context.Context, arg1 *registry.ListTagsWithDetailsRequest, arg2 ...grpc.CallOption) (*registry.ListTagsWithDetailsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListTagsWithDetails", varargs...)
	ret0, _ := ret[0].(*registry.ListTagsWithDetailsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTagsWithDetails indicates an expected call of ListTagsWithDetails.
func (mr *MockRegistryClientMockRecorder) ListTagsWithDetails(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTagsWithDetails", reflect.TypeOf((*MockRegistryClient)(nil).ListTagsWithDetails), varargs...)
}

// RemoveImage mocks base method.
func (m *MockRegistryClient) RemoveImage(arg0 context.Context, arg1 *registry.RemoveImageRequest, arg2 ...grpc.CallOption) (*registry.RemoveImageResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveImage", varargs...)
	ret0, _ := ret[0].(*registry.RemoveImageResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoveImage indicates an expected call of RemoveImage.
func (mr *MockRegistryClientMockRecorder) RemoveImage(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveImage", reflect.TypeOf((*MockRegistryClient)(nil).RemoveImage), varargs...)
}

// RepoAvailable mocks base method.
func (m *MockRegistryClient) RepoAvailable(arg0 context.Context, arg1 *registry.RepoAvailableRequest, arg2 ...grpc.CallOption) (*registry.RepoAvailableResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RepoAvailable", varargs...)
	ret0, _ := ret[0].(*registry.RepoAvailableResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RepoAvailable indicates an expected call of RepoAvailable.
func (mr *MockRegistryClientMockRecorder) RepoAvailable(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RepoAvailable", reflect.TypeOf((*MockRegistryClient)(nil).RepoAvailable), varargs...)
}

// SetImageVisibility mocks base method.
func (m *MockRegistryClient) SetImageVisibility(arg0 context.Context, arg1 *registry.SetImageVisibilityRequest, arg2 ...grpc.CallOption) (*registry.SetImageVisibilityResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetImageVisibility", varargs...)
	ret0, _ := ret[0].(*registry.SetImageVisibilityResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetImageVisibility indicates an expected call of SetImageVisibility.
func (mr *MockRegistryClientMockRecorder) SetImageVisibility(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetImageVisibility", reflect.TypeOf((*MockRegistryClient)(nil).SetImageVisibility), varargs...)
}
